(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{379:function(v,_,e){"use strict";e.r(_);var a=e(17),t=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"eip-4200-eof-靜態相對跳躍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eip-4200-eof-靜態相對跳躍"}},[v._v("#")]),v._v(" EIP-4200：EOF - 靜態相對跳躍")]),v._v(" "),_("h2",{attrs:{id:"注意事項"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注意事項"}},[v._v("#")]),v._v(" 注意事項")]),v._v(" "),_("p",[v._v("本文並沒有經過作者外的其他審查者審核，因此若內容有誤，請到 issue 區提出問題，我會儘速修改，謝謝。")]),v._v(" "),_("h2",{attrs:{id:"簡單介紹"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#簡單介紹"}},[v._v("#")]),v._v(" 簡單介紹")]),v._v(" "),_("p",[v._v("我們要在 EVM 指令中加入三個新的跳躍指令（"),_("code",[v._v("RJUMP")]),v._v("、"),_("code",[v._v("RJUMPI")]),v._v(" 和 "),_("code",[v._v("RJUMPV")]),v._v("），用來取代原本的動態 "),_("code",[v._v("JUMP")]),v._v(" 系列跳躍指令。這些指令可以告訴程式「跳到前面或後面的某個地方繼續執行」。這些新指令比舊的方法更省 Gas 費用，也更容易使用。")]),v._v(" "),_("h2",{attrs:{id:"為什麼我們需要這個"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#為什麼我們需要這個"}},[v._v("#")]),v._v(" 為什麼我們需要這個？")]),v._v(" "),_("p",[v._v("想像你在玩遊戲，有時會需要跳過某些關卡，或是回頭重新挑戰先前的部分。在電腦程式中，這種控制流程跳躍是非常常見的需求。")]),v._v(" "),_("p",[v._v("目前的 EVM 只有一種跳躍方式「動態跳躍」，就像是你每次想跳到哪裡都需要先查地圖，確認目的地("),_("code",[v._v("JUMPDEST")]),v._v(")才能跳。這種方式很靈活，但也有點浪費時間和資源。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("PUSH2 0x1234\nJUMP\n")])])]),_("p",[v._v("但這種方式有幾個缺點：")]),v._v(" "),_("ul",[_("li",[v._v("每次跳躍都必須事先查找目標位置是否為有效的 JUMPDEST")]),v._v(" "),_("li",[v._v("JUMPDEST 會消耗額外的 1 gas")]),v._v(" "),_("li",[v._v("靜態分析工具不容易預先知道跳躍目標")])]),v._v(" "),_("p",[v._v("其實在很多情況下，我們事先就知道要跳到哪裡，不需要每次都查地圖。就像你知道「跳到前面 5 步」或「跳到後面 3 步」這樣簡單的指令就好。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("RJUMP -5\n")])])]),_("p",[v._v("這就等於說：「從目前位置向前跳 5 個位元組」，不需要查表也不需要額外標記。")]),v._v(" "),_("p",[v._v("這個改變將提供一個更簡單的選擇。程式設計師可以根據需要選擇最適合的方法。這個新功能可以幫助我們：")]),v._v(" "),_("ol",[_("li",[v._v("省 Gas（使用和部署程式時都更便宜）")]),v._v(" "),_("li",[v._v("讓程式更容易分析和理解")])]),v._v(" "),_("h2",{attrs:{id:"規格說明"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#規格說明"}},[v._v("#")]),v._v(" 規格說明")]),v._v(" "),_("p",[v._v("我們要引入三個新指令：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("RJUMP")]),v._v(" (0xe0) - 直接跳躍到指定的相對位置")]),v._v(" "),_("li",[_("code",[v._v("RJUMPI")]),v._v(" (0xe1) - 如果條件成立，才跳躍到指定的相對位置")]),v._v(" "),_("li",[_("code",[v._v("RJUMPV")]),v._v(" (0xe2) - 根據一個數字選擇從多個跳躍目標中跳到其中一個")])]),v._v(" "),_("p",[v._v("如果是傳統 EVM 的程式碼，這些指令會導致程式停止執行，因此不會改變現有程式的行為。")]),v._v(" "),_("p",[v._v("如果是新式 EOFv1 格式的程式碼：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("RJUMP relative_offset")]),v._v(" 會把程式運行位置設定到「目前位置 + relative_offset」。")]),v._v(" "),_("li",[_("code",[v._v("RJUMPI relative_offset")]),v._v(" 會從堆疊中取出一個值（"),_("code",[v._v("condition")]),v._v("），如果這個值不是 0，就跳到「目前位置 + relative_offset」；如果是 0，就不跳躍。")]),v._v(" "),_("li",[_("code",[v._v("RJUMPV max_index relative_offset+")]),v._v(" 會從堆疊中取出一個值（"),_("code",[v._v("case")]),v._v("），如果這個值小於或等於 "),_("code",[v._v("max_index")]),v._v("，就跳到「目前位置 + relative_offset[case]」；否則不跳躍。")])]),v._v(" "),_("p",[_("code",[v._v("relative_offset")]),v._v(" 是一個 16 位元的"),_("strong",[v._v("有符號")]),v._v("（可正可負）的大端序數值。「目前位置」指的是整個指令（包括參數）之後的位置。")]),v._v(" "),_("p",[_("code",[v._v("RJUMPV")]),v._v(" 的參數比較特別："),_("code",[v._v("max_index")]),v._v(" 是一個 8 位元的無符號值，決定跳躍表的最大索引。後面的 "),_("code",[v._v("relative_offset")]),v._v(" 值的數量是 "),_("code",[v._v("max_index+1")]),v._v("。這樣可以有最多 256 個跳躍目標。"),_("code",[v._v("RJUMPV")]),v._v(" 至少需要一個 "),_("code",[v._v("relative_offset")]),v._v("，所以最少會佔用 4 個位元組。")]),v._v(" "),_("p",[v._v("我們也擴展了之前 EIP-3670 的驗證方法，確保每個 "),_("code",[v._v("RJUMP")]),v._v("/"),_("code",[v._v("RJUMPI")]),v._v("/"),_("code",[v._v("RJUMPV")]),v._v(" 的 "),_("code",[v._v("relative_offset")]),v._v(" 都指向一個有效的指令。這表示它不能指向 "),_("code",[v._v("PUSHn")]),v._v("/"),_("code",[v._v("RJUMP")]),v._v("/"),_("code",[v._v("RJUMPI")]),v._v("/"),_("code",[v._v("RJUMPV")]),v._v(" 的即時資料，也不能指向程式碼範圍外。它可以指向 "),_("code",[v._v("JUMPDEST")]),v._v("，但不是必須的。")]),v._v(" "),_("p",[v._v("因為目標位置是預先驗證的，所以這些指令的成本比動態跳躍更低："),_("code",[v._v("RJUMP")]),v._v(" 應該是 2 gas，"),_("code",[v._v("RJUMPI")]),v._v(" 和 "),_("code",[v._v("RJUMPV")]),v._v(" 應該是 4 gas。")]),v._v(" "),_("h2",{attrs:{id:"為什麼這樣設計"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#為什麼這樣設計"}},[v._v("#")]),v._v(" 為什麼這樣設計？")]),v._v(" "),_("h3",{attrs:{id:"相對定位"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#相對定位"}},[v._v("#")]),v._v(" 相對定位")]),v._v(" "),_("p",[v._v("我們選擇相對定位是為了支援可重新定位的程式碼。這也意味著程式碼片段可以被插入。在這個 EIP 之前，要達到同樣的目標，程式設計師會使用像 "),_("code",[v._v("PUSHn PC ADD JUMPI")]),v._v(" 這樣的技巧。")]),v._v(" "),_("p",[v._v("我們認為相對定位沒有明顯的缺點，而且它允許我們也棄用 "),_("code",[v._v("PC")]),v._v(" 指令。")]),v._v(" "),_("h3",{attrs:{id:"參數大小"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#參數大小"}},[v._v("#")]),v._v(" 參數大小")]),v._v(" "),_("p",[v._v("有符號的 16 位元參數意味著最大跳躍距離可以是 32767。如果在 "),_("code",[v._v("PC=0")]),v._v(" 的位置的程式碼以 "),_("code",[v._v("RJUMP")]),v._v(" 開始，就可以跳躍到 "),_("code",[v._v("PC=32770")]),v._v(" 的位置。")]),v._v(" "),_("p",[v._v("考慮到 "),_("code",[v._v("MAX_CODE_SIZE = 24576")]),v._v("（在 EIP-170 中）和 "),_("code",[v._v("MAX_INITCODE_SIZE = 49152")]),v._v("（在 EIP-3860 中），16 位元的參數足夠大了。")]),v._v(" "),_("h3",{attrs:{id:"沒有使用-jumpdest"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#沒有使用-jumpdest"}},[v._v("#")]),v._v(" 沒有使用 "),_("code",[v._v("JUMPDEST")])]),v._v(" "),_("p",[_("code",[v._v("JUMPDEST")]),v._v(" 有兩個用途：")]),v._v(" "),_("ol",[_("li",[v._v("有效地分割程式碼 — 這對於預先計算給定區塊的總 gas 用量很有用")]),v._v(" "),_("li",[v._v("明確顯示有效的位置（否則任何非資料位置都將是有效的）")])]),v._v(" "),_("p",[v._v("對於靜態跳躍，不需要這個功能，因為分析器可以在分析過程中輕鬆地從靜態跳躍參數中識別目標位置。")]),v._v(" "),_("p",[v._v("這裡有兩個好處：")]),v._v(" "),_("ol",[_("li",[v._v("每個跳躍目標不用浪費一個位元組的 "),_("code",[v._v("JUMPDEST")]),v._v("，也意味著在部署時每個跳躍目標可以節省 200 gas。")]),v._v(" "),_("li",[v._v("在執行過程中每次跳躍可以額外節省 1 gas，因為 "),_("code",[v._v("JUMPDEST")]),v._v(" 本身花費 1 gas，並且在跳躍過程中被「執行」。")])]),v._v(" "),_("h3",{attrs:{id:"rjumpv-的預設情況"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rjumpv-的預設情況"}},[v._v("#")]),v._v(" "),_("code",[v._v("RJUMPV")]),v._v(" 的預設情況")]),v._v(" "),_("p",[v._v("如果在 "),_("code",[v._v("RJUMPV")]),v._v(" 指令執行中沒有找到匹配項（即預設情況），程式會繼續執行而不跳躍。這允許在參數中的空缺處填入 "),_("code",[v._v("0")]),v._v("，並且讓程式設計師自己選擇實作方式。\n另一種方案是在沒有匹配的情況下異常中止。")]),v._v(" "),_("h3",{attrs:{id:"範例"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#範例"}},[v._v("#")]),v._v(" 範例")]),v._v(" "),_("h4",{attrs:{id:"rjump-0xe0"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rjump-0xe0"}},[v._v("#")]),v._v(" RJUMP (0xe0)")]),v._v(" "),_("p",[v._v("直接跳到目前位置 + relative_offset。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("# 指令\nPC=100:\n  RJUMP 0x0006       ; 直接跳到 PC=108\n  ...                ; 中間這段會被跳過\nPC=108:\n  STOP\n\n# ASCII 圖示：\n\n  100 ─┐\n       │ RJUMP +6\n  101  │\n  ...  │    ← 跳過\n  108 ┘→ STOP\n")])])]),_("h4",{attrs:{id:"rjumpi-0xe1"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rjumpi-0xe1"}},[v._v("#")]),v._v(" RJUMPI (0xe1)")]),v._v(" "),_("p",[v._v("根據條件跳躍。從堆疊中取出 condition，若不為 0，則跳到 PC + relative_offset。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("PUSH1 1        ; condition = true\nRJUMPI 0x0004  ; 跳到後面 if 區塊\n...\nSTOP\n\n# ASCII 圖示：\n\n堆疊： [1]         ← condition = true\n        │\n        ▼\nRJUMPI +4 ───→ if 區塊\n   │\n   └──────→ 不跳（若為 0）\n")])])]),_("h4",{attrs:{id:"rjumpv-0xe2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#rjumpv-0xe2"}},[v._v("#")]),v._v(" RJUMPV (0xe2)")]),v._v(" "),_("p",[v._v("從堆疊取出 case 數值，跳到對應的 relative_offset[case] 位置。最多支援 256 個跳躍目標。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("# 指令\nPUSH1 2\nRJUMPV 0x02\n  0x0004         ; case = 0\n  0x0006         ; case = 1\n  0x0008         ; case = 2 → 這個會被使用\n\n# ASCII 圖示：\n\n堆疊：[2] → case = 2\nRJUMPV max=2:\n  ├─ case 0 → offset +4\n  ├─ case 1 → offset +6\n  └─ case 2 → offset +8  ← 命中\n\n# 若 case 超過最大值（例如 3 > max_index=2），則不跳躍，繼續執行下一指令。\n")])])])])}),[],!1,null,null,null);_.default=t.exports}}]);