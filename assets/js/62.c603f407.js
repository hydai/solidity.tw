(window.webpackJsonp=window.webpackJsonp||[]).push([[62],{383:function(t,a,e){"use strict";e.r(a);var s=e(17),_=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"eip-4750-eof-函式功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eip-4750-eof-函式功能"}},[t._v("#")]),t._v(" EIP-4750 EOF 函式功能")]),t._v(" "),a("h2",{attrs:{id:"注意事項"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#注意事項"}},[t._v("#")]),t._v(" 注意事項")]),t._v(" "),a("p",[t._v("本文並沒有經過作者外的其他審查者審核，因此若內容有誤，請到 issue 區提出問題，我會儘速修改，謝謝。")]),t._v(" "),a("h2",{attrs:{id:"前言"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),a("p",[t._v("想像你在寫一個程式，就像組裝樂高積木一樣。以前我們只能用一整條長長的指令來完成所有工作，但現在我們可以把程式分成很多小塊，每一塊都是一個「函式」（功能），就像把不同的樂高積木組合起來。")]),t._v(" "),a("p",[t._v("引入這樣的特性，代表我們從過往沒有結構的傳統 EVM 程式碼，開始轉變成具備高度結構化的程式碼。透過這樣的改變能讓我們的程式碼更容易進行分析、最佳化、與理解。")]),t._v(" "),a("h2",{attrs:{id:"這個改進想要解決什麼問題"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#這個改進想要解決什麼問題"}},[t._v("#")]),t._v(" 這個改進想要解決什麼問題？")]),t._v(" "),a("p",[t._v("以前的程式就像一條長長的跑道，要跳來跳去很麻煩：")]),t._v(" "),a("ul",[a("li",[t._v("程式只能用「動態跳躍」，因此跑者無法在最初的時候知道跑道的真正軌跡，需要到正在跑的當下才會得知下一個目的地在哪（像隨便跳到某個地方）")]),t._v(" "),a("li",[t._v("這樣很混亂，不只人類在分析與計算有難度，且電腦也很難在最佳化上有很好的做法")]),t._v(" "),a("li",[t._v("更多的是我們還需要動態驗證許多的指令，以確保在執行期間不會出現問題，這樣將導致程式碼執行的成本被迫增加")])]),t._v(" "),a("h2",{attrs:{id:"新的解決方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新的解決方案"}},[t._v("#")]),t._v(" 新的解決方案")]),t._v(" "),a("p",[t._v("現在我們引入了兩個新的指令：")]),t._v(" "),a("ol",[a("li",[a("strong",[a("code",[t._v("CALLF")])]),t._v("（呼叫函式）- 就像打電話給朋友請他幫忙")]),t._v(" "),a("li",[a("strong",[a("code",[t._v("RETF")])]),t._v("（回傳結果）- 朋友做完事情後回電話告訴你結果")])]),t._v(" "),a("h2",{attrs:{id:"如何運作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何運作"}},[t._v("#")]),t._v(" 如何運作？")]),t._v(" "),a("h3",{attrs:{id:"型態區段-type-section"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#型態區段-type-section"}},[t._v("#")]),t._v(" 型態區段（Type Section）")]),t._v(" "),a("p",[t._v("每個函式都有一個標籤，告訴我們：")]),t._v(" "),a("ul",[a("li",[t._v("需要多少東西作為輸入（像食譜需要多少材料）")]),t._v(" "),a("li",[t._v("會產生多少東西作為輸出（像食譜會做出多少個餅乾）")]),t._v(" "),a("li",[t._v("最多會用到多少空間（像廚房檯面要多大）")])]),t._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[t._v("每個函式的資訊包含：\n- 輸入數量：0-255\n- 輸出數量：0-255  \n- 最大堆疊增加：0-65535\n")])])]),a("h4",{attrs:{id:"函式資料結構"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#函式資料結構"}},[t._v("#")]),t._v(" 函式資料結構")]),t._v(" "),a("div",{staticClass:"language-txt extra-class"},[a("pre",{pre:!0,attrs:{class:"language-txt"}},[a("code",[t._v("┌─────────────┬─────────────┬────────────────────┐\n│  輸入數量   │  輸出數量   │ 最大堆疊增加量     │\n│ (0~255)     │ (0~255)     │ (0~65535)          │\n└─────────────┴─────────────┴────────────────────┘\n")])])]),a("h3",{attrs:{id:"新的執行狀態-回傳堆疊-return-stack"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#新的執行狀態-回傳堆疊-return-stack"}},[t._v("#")]),t._v(" 新的執行狀態：回傳堆疊（Return Stack）")]),t._v(" "),a("p",[t._v("EVM 現在有第二個堆疊：「回傳堆疊」，用來儲存函式呼叫的返回資訊。")]),t._v(" "),a("h4",{attrs:{id:"回傳堆疊結構"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回傳堆疊結構"}},[t._v("#")]),t._v(" 回傳堆疊結構")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("每次 "),a("code",[t._v("CALLF")]),t._v(" 會壓入一個回傳項目：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(code_section_index = 呼叫前的區段,\n offset = CALLF 結束後的 PC)\n")])])])]),t._v(" "),a("li",[a("p",[t._v("若回傳堆疊超過 1024 項目會中止")])]),t._v(" "),a("li",[a("p",[t._v("呼叫時也會檢查 operand stack 是否會超過 1024 的限制（加上 callee 的最大堆疊增量）")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("RETF")]),t._v(" 從堆疊中取出該項，跳回呼叫處")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("最大容量：1024 個項目\n")])])])])]),t._v(" "),a("h4",{attrs:{id:"回傳堆疊操作示意"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#回傳堆疊操作示意"}},[t._v("#")]),t._v(" 回傳堆疊操作示意")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("初始時：\nReturn Stack: []\n\nCALLF：\nReturn Stack: [（MainSection, offset=CALLF+2）]\n\nCALLF（巢狀）：\nReturn Stack: [（MainSection, offset=CALLF+2), (Func1Section, offset=CALLF+2)]\n\nRETF：\nReturn Stack: [(MainSection, offset=CALLF+2)]\n→ 回到 Func1\n\nRETF：\nReturn Stack: []\n→ 回到 Main\n")])])]),a("h3",{attrs:{id:"callf-指令-呼叫函式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callf-指令-呼叫函式"}},[t._v("#")]),t._v(" "),a("code",[t._v("CALLF")]),t._v(" 指令（呼叫函式）")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("CALLF(target_section_index: u16)\n")])])]),a("ol",[a("li",[a("p",[t._v("有一個 16-bit 無號整數參數（big-endian 編碼），代表要呼叫的目標程式區段。")])]),t._v(" "),a("li",[a("p",[t._v("根據 "),a("RouterLink",{attrs:{to:"/head-first-eof/eip-5450.html"}},[t._v("EIP-5450")]),t._v(" 驗證，保證 operand stack 有足夠輸入供目標函式使用。")],1)]),t._v(" "),a("li",[a("p",[t._v("如果 "),a("code",[t._v("operand stack")]),t._v(" 的目前高度 + "),a("code",[t._v("type[target_section_index].max_stack_increase")]),t._v(" 超過 1024，會異常中止。")])]),t._v(" "),a("li",[a("p",[t._v("若回傳堆疊已滿（1024 個項目），則異常中止。")])]),t._v(" "),a("li",[a("p",[t._v("花費 5 單位 gas。")])]),t._v(" "),a("li",[a("p",[t._v("不操作 operand stack。")])]),t._v(" "),a("li",[a("p",[t._v("壓入 return stack：")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(code_section_index = 呼叫前所在區段,\n offset = CALLF 指令後下一個指令位置)\n")])])])]),t._v(" "),a("li",[a("p",[t._v("將 "),a("code",[t._v("current_section_index = target_section_index")]),t._v(" 並將 PC 設為 0，開始執行新函式。")])])]),t._v(" "),a("h3",{attrs:{id:"retf-指令-回傳結果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#retf-指令-回傳結果"}},[t._v("#")]),t._v(" "),a("code",[t._v("RETF")]),t._v(" 指令（回傳結果）")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("RETF\n")])])]),a("ol",[a("li",[t._v("無參數。")]),t._v(" "),a("li",[t._v("根據驗證，保證 operand stack 有正確數量的輸出值。")]),t._v(" "),a("li",[t._v("花費 3 單位 gas。")]),t._v(" "),a("li",[t._v("不操作 operand stack。")]),t._v(" "),a("li",[t._v("從回傳堆疊取出物件 "),a("code",[t._v("(section, offset)")]),t._v("，跳回該位置繼續執行。")])]),t._v(" "),a("blockquote",[a("p",[t._v("根據驗證規則，0 號主程式區段不允許使用 "),a("code",[t._v("RETF")]),t._v("，其主因是在合法程式中執行 RETF 時，回傳堆疊必不為空，但在執行之初， 0 號主程式區段只能是空的回傳堆疊。")])]),t._v(" "),a("h3",{attrs:{id:"callf-retf-執行流程圖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#callf-retf-執行流程圖"}},[t._v("#")]),t._v(" CALLF / RETF 執行流程圖")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("┌────────────┐\n│ 執行主程式 │\n└─────┬──────┘\n      │\n      ▼\n┌────────────┐\n│  執行 CALLF │───┐\n└─────┬──────┘   │\n      │ 寫入返回位置\n      ▼         │\n┌────────────┐  │\n│  進入函式區 │◀─┘\n└─────┬──────┘\n      │\n      ▼\n┌────────────┐\n│ 執行 RETF   │────┐\n└─────┬──────┘    │\n      │ 讀取返回位置\n      ▼            │\n┌────────────┐   ◀─┘\n│ 回主程式繼續 │\n└────────────┘\n")])])]),a("h3",{attrs:{id:"🧪-巢狀呼叫堆疊流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#🧪-巢狀呼叫堆疊流程"}},[t._v("#")]),t._v(" 🧪 巢狀呼叫堆疊流程")]),t._v(" "),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("(0) Main Function\n  ↓ CALLF(1)\n(1) Function 1\n  ↓ CALLF(2)\n(2) Function 2\n  ↓ RETF → 回到 Function 1\n(1) Function 1\n  ↓ RETF → 回到 Main Function\n")])])]),a("div",{staticClass:"language-text extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("堆疊變化：\nStep 1: []\nStep 2: [（0, Main_PC)]\nStep 3: [(0, Main_PC), (1, Func1_PC)]\nStep 4: [(0, Main_PC)]\nStep 5: []\n")])])]),a("h3",{attrs:{id:"程式碼驗證規則"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#程式碼驗證規則"}},[t._v("#")]),t._v(" 程式碼驗證規則")]),t._v(" "),a("p",[t._v("為了確保程式碼正確，我們有這些規則：")]),t._v(" "),a("ol",[a("li",[t._v("不能呼叫不存在的函式")]),t._v(" "),a("li",[t._v("跳躍指令不能跳到函式外面")]),t._v(" "),a("li",[t._v("每個函式都要能從主程式到達，不可有死碼")]),t._v(" "),a("li",[t._v("禁止使用舊的動態跳躍指令")]),t._v(" "),a("li",[t._v("每個函式的返回堆疊必須在執行 RETF 前不為空")])]),t._v(" "),a("h3",{attrs:{id:"被禁用的指令"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#被禁用的指令"}},[t._v("#")]),t._v(" 被禁用的指令")]),t._v(" "),a("p",[t._v("以下指令在新版本中不能使用：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("JUMP")]),t._v(" 和 "),a("code",[t._v("JUMPI")])]),t._v(" "),a("li",[a("code",[t._v("JUMPDEST")]),t._v("（轉為 "),a("code",[t._v("NOP")]),t._v(" 無操作指令）")]),t._v(" "),a("li",[a("code",[t._v("PC")])])]),t._v(" "),a("h2",{attrs:{id:"執行過程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#執行過程"}},[t._v("#")]),t._v(" 執行過程")]),t._v(" "),a("ol",[a("li",[t._v("程式從第 0 程式區段開始執行")]),t._v(" "),a("li",[t._v("回傳堆疊初始為空")]),t._v(" "),a("li",[t._v("除 "),a("code",[t._v("CALLF")]),t._v(" 外，不需檢查堆疊高度限制")])]),t._v(" "),a("h2",{attrs:{id:"為什麼這樣設計"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#為什麼這樣設計"}},[t._v("#")]),t._v(" 為什麼這樣設計？")]),t._v(" "),a("h3",{attrs:{id:"讓-jumpdest-變成-nop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#讓-jumpdest-變成-nop"}},[t._v("#")]),t._v(" 讓 "),a("code",[t._v("JUMPDEST")]),t._v(" 變成 "),a("code",[t._v("NOP")])]),t._v(" "),a("p",[t._v("因為 "),a("code",[t._v("JUMPDEST")]),t._v(" 原本只是跳躍標記，現在已不再需要：")]),t._v(" "),a("ol",[a("li",[t._v("可作為效能測試點")]),t._v(" "),a("li",[t._v("幫助程式碼對齊")]),t._v(" "),a("li",[t._v("作為佔位符指令使用")])]),t._v(" "),a("h3",{attrs:{id:"不再需要掃描-jumpdest"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#不再需要掃描-jumpdest"}},[t._v("#")]),t._v(" 不再需要掃描 "),a("code",[t._v("JUMPDEST")])]),t._v(" "),a("p",[t._v("以前需掃描所有可能跳躍目標以進行驗證。現在使用靜態結構與相對位址後，這項工作不再必要，提升驗證與執行效率。")]),t._v(" "),a("h2",{attrs:{id:"相容性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#相容性"}},[t._v("#")]),t._v(" 相容性")]),t._v(" "),a("ul",[a("li",[t._v("僅適用於 EOFv1 格式的合約")]),t._v(" "),a("li",[t._v("舊有合約完全不受影響")])]),t._v(" "),a("h2",{attrs:{id:"花費成本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#花費成本"}},[t._v("#")]),t._v(" 花費成本")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("CALLF")]),t._v("：5 Gas")]),t._v(" "),a("li",[a("code",[t._v("RETF")]),t._v("：3 Gas")])]),t._v(" "),a("h2",{attrs:{id:"總結"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#總結"}},[t._v("#")]),t._v(" 總結")]),t._v(" "),a("p",[t._v("EIP-4750 把以往「一條到底」的 EVM 程式，轉換成可以分段、結構化、具可讀性的函式程式風格。搭配回傳堆疊(return stack)的設計，不但使程式更容易分析與最佳化，就像從一堆線變成一組有邏輯的樂高積木，EVM 也即將迎來新的程式架構時代！")])])}),[],!1,null,null,null);a.default=_.exports}}]);