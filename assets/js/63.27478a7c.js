(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{384:function(_,v,t){"use strict";t.r(v);var a=t(17),n=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"eip-6206-jumpf-與非回傳函式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eip-6206-jumpf-與非回傳函式"}},[_._v("#")]),_._v(" EIP-6206 - JUMPF 與非回傳函式")]),_._v(" "),v("h2",{attrs:{id:"注意事項"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#注意事項"}},[_._v("#")]),_._v(" 注意事項")]),_._v(" "),v("p",[_._v("本文並沒有經過作者外的其他審查者審核，因此若內容有誤，請到 issue 區提出問題，我會儘速修改，謝謝。")]),_._v(" "),v("h2",{attrs:{id:"摘要"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[_._v("#")]),_._v(" 摘要")]),_._v(" "),v("p",[_._v("本 EIP 是對於 EIP-4750 EOF 函式的擴充，提供尾端呼叫最佳化機制，透過加入了一個新指令 "),v("code",[_._v("JUMPF")]),_._v("，可在不新增回傳堆疊框架的情況下跳轉至其他程式碼區段。")]),_._v(" "),v("p",[_._v("同時也擴充了型別區段的格式，允許標註某個區段為「非回傳區段」，並為跳轉至這類區段的 "),v("code",[_._v("JUMPF")]),_._v(" 指令提供簡化的堆疊驗證邏輯。")]),_._v(" "),v("h2",{attrs:{id:"目的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#目的"}},[_._v("#")]),_._v(" 目的")]),_._v(" "),v("p",[_._v("在常見的函式設計中，某些函式在執行結束時只會呼叫另一個函式然後立即回傳。"),v("code",[_._v("JUMPF")]),_._v(" 能在不需建立新回傳堆疊框架的情況下，切換至另一個區段執行，進而最佳化這類尾端呼叫行為。")]),_._v(" "),v("p",[_._v("若在驗證階段已能確定某函式永遠不會將控制流程回傳給呼叫端，則使用 "),v("code",[_._v("JUMPF")]),_._v(" 時可將其視為終止指令，允許操作數堆疊在執行終止時保留額外資料。這將提供編譯器更多最佳化空間，無論是在程式碼體積或 gas 消耗上皆具優勢。")]),_._v(" "),v("p",[_._v("此特性特別適用於以 "),v("code",[_._v("REVERT")]),_._v(" 結尾的錯誤處理輔助函式。這些輔助函式經常在多個分支中重複使用，若無需在 "),v("code",[_._v("JUMPF")]),_._v(" 前先移除堆疊上的多餘項目，就能以更有效率的方式進行抽取與重用。")]),_._v(" "),v("h2",{attrs:{id:"實際例子-費波那契數列計算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#實際例子-費波那契數列計算"}},[_._v("#")]),_._v(" 實際例子：費波那契數列計算")]),_._v(" "),v("p",[_._v("費波那契數列定義如下：")]),_._v(" "),v("ul",[v("li",[_._v("F(0) = 0")]),_._v(" "),v("li",[_._v("F(1) = 1")]),_._v(" "),v("li",[_._v("F(n) = F(n-1) + F(n-2)，當 n > 1")])]),_._v(" "),v("h3",{attrs:{id:"傳統方法-使用-callf-與-retf"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#傳統方法-使用-callf-與-retf"}},[_._v("#")]),_._v(" 傳統方法（使用 CALLF 與 RETF）")]),_._v(" "),v("p",[_._v("區段 0（主程式）:\nPUSH 10         // 計算 F(10)\nCALLF 1         // 呼叫費波那契函式\nSTOP            // 結束執行")]),_._v(" "),v("p",[_._v("區段 1（fib 函式）:\nDUP1            // 複製 n\nPUSH 2\nLT              // n < 2 ?\nJUMPI base_case // 是的話跳到基本情況")]),_._v(" "),v("p",[_._v("DUP1\nPUSH 1\nSWAP1\nSUB             // n-1\nCALLF 1         // 呼叫 F(n-1)")]),_._v(" "),v("p",[_._v("SWAP1\nPUSH 2\nSWAP1\nSUB             // n-2\nCALLF 1         // 呼叫 F(n-2)")]),_._v(" "),v("p",[_._v("ADD             // F(n-1) + F(n-2)\nRETF")]),_._v(" "),v("p",[_._v("base_case:\nRETF            // 回傳 n（F(0) 或 F(1)）")]),_._v(" "),v("h3",{attrs:{id:"使用尾端遞迴與-jumpf-最佳化版本"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用尾端遞迴與-jumpf-最佳化版本"}},[_._v("#")]),_._v(" 使用尾端遞迴與 JUMPF 最佳化版本")]),_._v(" "),v("p",[_._v("我們可以將此函式改寫為尾端遞迴形式，並在最後使用 "),v("code",[_._v("JUMPF")]),_._v("：")]),_._v(" "),v("p",[_._v("區段 0（主程式，非回傳）:\nPUSH 10         // n\nPUSH 0          // a = F(0)\nPUSH 1          // b = F(1)\nJUMPF 1         // 進入 fibTail 區段")]),_._v(" "),v("p",[_._v("區段 1（fibTail 函式）:\n// Stack: [n, a, b]\nDUP1\nISZERO\nJUMPI return_a  // 若 n == 0，回傳 a")]),_._v(" "),v("p",[_._v("SWAP1\nDUP3\nADD             // 計算 a+b\nSWAP2\nPUSH 1\nSWAP1\nSUB             // n-1\nSWAP1\nSWAP2           // 參數變為 [a+b, n-1, b]")]),_._v(" "),v("p",[_._v("JUMPF 1         // 尾呼叫 fibTail(n-1, b, a+b)")]),_._v(" "),v("p",[_._v("return_a:\nSWAP1\nSWAP2\nPOP\nPOP\nRETF")]),_._v(" "),v("h3",{attrs:{id:"執行流程比較"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#執行流程比較"}},[_._v("#")]),_._v(" 執行流程比較")]),_._v(" "),v("div",{staticClass:"language-txt extra-class"},[v("pre",{pre:!0,attrs:{class:"language-txt"}},[v("code",[_._v("傳統方法:                           使用 JUMPF 優化:\n+—————+                  +––––––––+\n| CALLF fib(10) |                  | JUMPF fibTail  |\n+—————+                  +––––––––+\n|                                  |\nv                                  v\n+—————+                  +––––––––+\n| 建立回傳框架   |                  | 無需建立回傳框架 |\n+—————+                  +––––––––+\n|                                  |\nv                                  v\n遞迴呼叫                          迭代執行\n(堆疊框架增長)                     (不增加堆疊框架)\n|                                  |\nv                                  v\n+—————+                  +––––––––+\n| 多次 CALLF/RETF|                  | 多次 JUMPF     |\n+—————+                  +––––––––+\n|                                  |\nv                                  v\n+—————+                  +––––––––+\n| 回傳堆疊展開   |                  | 當 n=0 時回傳   |\n+—————+                  +––––––––+\n")])])]),v("h2",{attrs:{id:"規格"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#規格"}},[_._v("#")]),_._v(" 規格")]),_._v(" "),v("h3",{attrs:{id:"型別區段變更"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#型別區段變更"}},[_._v("#")]),_._v(" 型別區段變更")]),_._v(" "),v("p",[_._v("若某區段在執行後永遠不會回傳，則可標記為「非回傳區段」。此類區段的 "),v("code",[_._v("outputs")]),_._v(" 欄位在型別區段中設為 "),v("code",[_._v("0x80")]),_._v("。")]),_._v(" "),v("p",[_._v("第一個程式碼區段，即 main 程式區段必須為非回傳區段，且不接受任何輸入。")]),_._v(" "),v("h3",{attrs:{id:"執行語意"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#執行語意"}},[_._v("#")]),_._v(" 執行語意")]),_._v(" "),v("p",[_._v("新增指令："),v("code",[_._v("JUMPF (0xe5)")])]),_._v(" "),v("ol",[v("li",[v("code",[_._v("JUMPF")]),_._v(" 具一個立即參數 "),v("code",[_._v("target_section_index")]),_._v("，為 16 位元無號 big-endian 整數，代表目標的程式碼區段。")]),_._v(" "),v("li",[_._v("若執行後的堆疊深度超過 "),v("code",[_._v("1024 - type[target].max_stack_increase")]),_._v("，則導致異常終止。")]),_._v(" "),v("li",[_._v("執行時會將目前區段設為目標區段，"),v("code",[_._v("PC")]),_._v(" 設為 0，但不更動回傳堆疊。")]),_._v(" "),v("li",[_._v("消耗 5 gas。")]),_._v(" "),v("li",[_._v("不對操作數堆疊進行 pop 或 push 操作。")])]),_._v(" "),v("p",[_._v("對於傳統位元組碼，執行 "),v("code",[_._v("JUMPF")]),_._v(" 將觸發異常終止。")]),_._v(" "),v("h3",{attrs:{id:"程式碼驗證"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#程式碼驗證"}},[_._v("#")]),_._v(" 程式碼驗證")]),_._v(" "),v("p",[_._v("對每個 "),v("code",[_._v("JUMPF")]),_._v("：")]),_._v(" "),v("ul",[v("li",[v("code",[_._v("target_section_index")]),_._v(" 必須小於區段總數。")]),_._v(" "),v("li",[_._v("需滿足以下條件之一：\n"),v("ul",[v("li",[v("code",[_._v("type[current].outputs")]),_._v(" ≥ "),v("code",[_._v("type[target].outputs")])]),_._v(" "),v("li",[_._v("或 "),v("code",[_._v("type[target].outputs == 0x80")])])])]),_._v(" "),v("li",[_._v("若跳轉至非回傳區段，需滿足："),v("code",[_._v("stack_height_min >= type[target].inputs")])]),_._v(" "),v("li",[_._v("若跳轉至可回傳區段，需滿足："),v("code",[_._v("stack_height_min == stack_height_max == type[current].outputs - type[target].outputs + type[target].inputs")])]),_._v(" "),v("li",[v("code",[_._v("stack_height_max ≤ 1024 - type[target].max_stack_increase")])]),_._v(" "),v("li",[v("code",[_._v("JUMPF")]),_._v(" 被視為終止指令，不可有後續指令")]),_._v(" "),v("li",[_._v("若任何 "),v("code",[_._v("RJUMP*")]),_._v(" 偏移至 "),v("code",[_._v("JUMPF")]),_._v(" 的立即參數部分，驗證失敗")]),_._v(" "),v("li",[v("code",[_._v("CALLF")]),_._v(" 不可呼叫非回傳區段（即 "),v("code",[_._v("outputs == 0x80")]),_._v("）")])]),_._v(" "),v("h4",{attrs:{id:"非回傳狀態驗證"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#非回傳狀態驗證"}},[_._v("#")]),_._v(" 非回傳狀態驗證")]),_._v(" "),v("p",[_._v("當且僅當某區段不含 "),v("code",[_._v("RETF")]),_._v(" 且僅使用 "),v("code",[_._v("JUMPF")]),_._v(" 指向其他非回傳區段時，該區段才可被標記為非回傳。")]),_._v(" "),v("h2",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[_._v("#")]),_._v(" 原理")]),_._v(" "),v("h3",{attrs:{id:"為何允許跳轉至輸出較少的區段"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#為何允許跳轉至輸出較少的區段"}},[_._v("#")]),_._v(" 為何允許跳轉至輸出較少的區段？")]),_._v(" "),v("p",[_._v("為避免重複程式碼，"),v("code",[_._v("JUMPF")]),_._v(" 允許從輸出較多的區段跳轉至輸出較少的區段，只要這些額外的輸出已在目前區段補足。這樣一來，共用的輔助函式就可以通用使用，無需硬性對應輸出數量。")]),_._v(" "),v("div",{staticClass:"language-txt extra-class"},[v("pre",{pre:!0,attrs:{class:"language-txt"}},[v("code",[_._v("傳統函式模式：                      使用 JUMPF 的優化模式：\n+––––+                          +––––+\n| 函式 A  |                          | 函式 A  |\n+––––+                          +––––+\n|                                   |\n| CALLF B                           | JUMPF B\n|                                   |\nv                                   v\n+––––+                          +––––+\n| 函式 B  |                          | 函式 B  |\n+––––+                          +––––+\n|                                   |\n| RETF                              | (無需回傳)\n|                                   |\nv                                   |\n+––––+                              |\n| 函式 A  |                              |\n+––––+                              |\n|                                   |\n| RETF                              |\nv                                   v\n")])])])])}),[],!1,null,null,null);v.default=n.exports}}]);