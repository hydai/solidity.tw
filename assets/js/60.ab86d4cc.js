(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{380:function(t,_,a){"use strict";a.r(_);var v=a(17),s=Object(v.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"eip-663-swapn、dupn-和-exchange-指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eip-663-swapn、dupn-和-exchange-指令"}},[t._v("#")]),t._v(" EIP-663：SWAPN、DUPN 和 EXCHANGE 指令")]),t._v(" "),_("h2",{attrs:{id:"注意事項"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注意事項"}},[t._v("#")]),t._v(" 注意事項")]),t._v(" "),_("p",[t._v("本文並沒有經過作者外的其他審查者審核，因此若內容有誤，請到 issue 區提出問題，我會儘速修改，謝謝。")]),t._v(" "),_("h2",{attrs:{id:"_1-摘要-abstract"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-摘要-abstract"}},[t._v("#")]),t._v(" 1. 摘要（Abstract）")]),t._v(" "),_("ul",[_("li",[t._v("以前，EVM 只能使用 "),_("code",[t._v("SWAP1")]),t._v(" 到 "),_("code",[t._v("SWAP16")]),t._v("、"),_("code",[t._v("DUP1")]),t._v(" 到 "),_("code",[t._v("DUP16")]),t._v("，也就是只能操作頂層的 16 個資料。")]),t._v(" "),_("li",[t._v("現在要新增三個指令："),_("code",[t._v("SWAPN")]),t._v("、"),_("code",[t._v("DUPN")]),t._v("、"),_("code",[t._v("EXCHANGE")]),t._v("，就能存取更深層的資料了。")])]),t._v(" "),_("h2",{attrs:{id:"_2-動機-motivation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-動機-motivation"}},[t._v("#")]),t._v(" 2. 動機（Motivation）")]),t._v(" "),_("ol",[_("li",[t._v("EVM 的堆疊最多可容納 1024 個資料，但原先只能輕鬆存取最頂層的 16 個項目，對於更深層的資料必須透過寫入記憶體或依賴編譯器最佳化，這會使程式變得複雜且效率降低。")]),t._v(" "),_("li",[t._v("在 EVM 上實作函式時，函式的輸入輸出參數數量經常超過 16 個，導致編譯器必須進行複雜的排程工作。")]),t._v(" "),_("li",[t._v("某些編譯器在進行堆疊最佳化（相當於變數管理）時，需要交換不同深度位置的資料，目前必須執行三條指令才能完成交換，新增的指令將可一步到位。")])]),t._v(" "),_("h2",{attrs:{id:"_3-新增的三個指令-specification"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-新增的三個指令-specification"}},[t._v("#")]),t._v(" 3. 新增的三個指令（Specification）")]),t._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("1. DUPN     （opcode = 0xe6）\n2. SWAPN    （opcode = 0xe7）\n3. EXCHANGE （opcode = 0xe8）\n")])])]),_("ul",[_("li",[t._v("在舊的「非 EOF」格式中，遇到這三個指令會直接回傳錯誤並停止執行（維持現有行為）。")]),t._v(" "),_("li",[t._v("只有在新格式（EOF1）中才會啟用這三個指令。")])]),t._v(" "),_("h3",{attrs:{id:"_3-1-立即參數-immediate"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-立即參數-immediate"}},[t._v("#")]),t._v(" 3.1 立即參數（Immediate）")]),t._v(" "),_("p",[t._v("這三個指令後面都必須跟隨一個 8 位元（0~255）的參數 "),_("code",[t._v("imm")]),t._v("：")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("DUPN")]),t._v("、"),_("strong",[t._v("SWAPN")]),t._v("：\n"),_("ul",[_("li",[_("code",[t._v("n = imm + 1")])])])]),t._v(" "),_("li",[_("strong",[t._v("EXCHANGE")]),t._v("：\n"),_("ul",[_("li",[_("code",[t._v("n = (imm >> 4) + 1")])]),t._v(" "),_("li",[_("code",[t._v("m = (imm & 0x0F) + 1")])])])])]),t._v(" "),_("h2",{attrs:{id:"_4-驗證規則-validation"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-驗證規則-validation"}},[t._v("#")]),t._v(" 4. 驗證規則（Validation）")]),t._v(" "),_("ol",[_("li",[t._v("禁止使用跳躍指令跳轉到這三個新指令的立即參數位元組。")]),t._v(" "),_("li",[t._v("當堆疊深度不足時，不能執行這三個指令：\n"),_("ul",[_("li",[_("strong",[t._v("DUPN")]),t._v("：執行前必須有 ≥ n 個資料，執行後資料數【+1】")]),t._v(" "),_("li",[_("strong",[t._v("SWAPN")]),t._v("：執行前必須有 ≥ n+1 個資料，執行後深度不變")]),t._v(" "),_("li",[_("strong",[t._v("EXCHANGE")]),t._v("：執行前必須有 ≥ n+m+1 個資料，執行後深度不變")])])])]),t._v(" "),_("h2",{attrs:{id:"_5-執行語義-execution-semantics"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-執行語義-execution-semantics"}},[t._v("#")]),t._v(" 5. 執行語義（Execution Semantics）")]),t._v(" "),_("ol",[_("li",[_("strong",[t._v("DUPN")]),t._v("：將第 n 個資料（從上往下計算）"),_("strong",[t._v("複製")]),t._v("到堆疊頂端")]),t._v(" "),_("li",[_("strong",[t._v("SWAPN")]),t._v("：將第 n+1 個資料和頂端資料"),_("strong",[t._v("交換")]),t._v("位置")]),t._v(" "),_("li",[_("strong",[t._v("EXCHANGE")]),t._v("：將第 n+1 個資料和第 n+m+1 個資料"),_("strong",[t._v("交換")]),t._v("位置")])]),t._v(" "),_("p",[t._v("這三個指令的 Gas 費用皆為 3。")]),t._v(" "),_("h2",{attrs:{id:"_6-範例說明-examples"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-範例說明-examples"}},[t._v("#")]),t._v(" 6. 範例說明（Examples）")]),t._v(" "),_("p",[t._v("為了更清楚說明，以下提供三個範例並附上 ASCII 圖示，展示各指令執行前後的堆疊狀態。")]),t._v(" "),_("h3",{attrs:{id:"例子-1-dupn-2-複製第-3-個資料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#例子-1-dupn-2-複製第-3-個資料"}},[t._v("#")]),t._v(" 例子 1："),_("code",[t._v("DUPN 2")]),t._v("（複製第 3 個資料）")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("指令")]),t._v("："),_("code",[t._v("DUPN 2")])]),t._v(" "),_("li",[_("strong",[t._v("計算")]),t._v("："),_("code",[t._v("n = 2 + 1 = 3")])]),t._v(" "),_("li",[_("strong",[t._v("動作")]),t._v("：複製第 3 個位置的資料 (C) 到堆疊頂端")])]),t._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("初始堆疊（頂端在上）：\n│ E │  ← 第 1 個\n│ D │  ← 第 2 個\n│ C │  ← 第 3 個\n│ B │  ← 第 4 個\n│ A │  ← 第 5 個\n\n執行後：\n│ C │  ← 新的頂端（C 複製到頂端）\n│ E │  ← 原第 1 個\n│ D │  ← 原第 2 個\n│ C │  ← 原第 3 個\n│ B │  ← 原第 4 個\n│ A │  ← 原第 5 個\n")])])]),_("h3",{attrs:{id:"例子-2-swapn-3-交換第-5-個資料與頂端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#例子-2-swapn-3-交換第-5-個資料與頂端"}},[t._v("#")]),t._v(" 例子 2："),_("code",[t._v("SWAPN 3")]),t._v("（交換第 5 個資料與頂端）")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("指令")]),t._v("："),_("code",[t._v("SWAPN 3")])]),t._v(" "),_("li",[_("strong",[t._v("計算")]),t._v("："),_("code",[t._v("n = 3 + 1 = 4")]),t._v("，要交換第 (n+1)=5 個和頂端")]),t._v(" "),_("li",[_("strong",[t._v("動作")]),t._v("：交換 E ↔ A")])]),t._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("初始堆疊：\n│ E │  ← 頂端\n│ D │  \n│ C │  \n│ B │  \n│ A │  ← 第 5 個\n\n執行後：\n│ A │  ← 原第 5 個\n│ D │  \n│ C │  \n│ B │  \n│ E │  ← 原頂端\n")])])]),_("h3",{attrs:{id:"例子-3-exchange-0x02-交換第-2-個與第-5-個資料"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#例子-3-exchange-0x02-交換第-2-個與第-5-個資料"}},[t._v("#")]),t._v(" 例子 3："),_("code",[t._v("EXCHANGE 0x02")]),t._v("（交換第 2 個與第 5 個資料）")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("指令")]),t._v("："),_("code",[t._v("EXCHANGE 0x02")])]),t._v(" "),_("li",[_("strong",[t._v("計算")]),t._v("：\n"),_("ul",[_("li",[_("code",[t._v("n = (0x02 >> 4) + 1 = 0 + 1 = 1")])]),t._v(" "),_("li",[_("code",[t._v("m = (0x02 & 0x0F) + 1 = 2 + 1 = 3")])]),t._v(" "),_("li",[t._v("要交換第 (n+1)=2 個和第 (n+m+1)=5 個")])])]),t._v(" "),_("li",[_("strong",[t._v("動作")]),t._v("：交換 D ↔ A")])]),t._v(" "),_("div",{staticClass:"language-text extra-class"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[t._v("初始堆疊：\n│ E │  \n│ D │  ← 第 2 個\n│ C │  \n│ B │  \n│ A │  ← 第 5 個\n\n執行後：\n│ E │  \n│ A │  ← 原第 5 個\n│ C │  \n│ B │  \n│ D │  ← 原第 2 個\n")])])]),_("h2",{attrs:{id:"_7-設計理念-rationale"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-設計理念-rationale"}},[t._v("#")]),t._v(" 7. 設計理念（Rationale）")]),t._v(" "),_("ul",[_("li",[_("strong",[t._v("為什麼使用立即參數？")]),t._v("\n避免動態參數變化，讓靜態分析更簡單，方便於程式檢查。")]),t._v(" "),_("li",[_("strong",[t._v("為什麼限制在 255？")]),t._v("\n堆疊最深也只有 1024，256 的深度除了已經比 16 有顯著改善，且以達 1/4 的總深度。在日常使用情境中不容易出現更多的需求，此外，再增加一個位元會將會帶來過大的成本且也沒如此強烈的需求。")]),t._v(" "),_("li",[_("strong",[t._v("為什麼要有 EXCHANGE？")]),t._v("\n編譯器有時需要一次交換兩個不同深度的位置，EXCHANGE 能夠一條指令完成，不需要使用三條指令。")])]),t._v(" "),_("h2",{attrs:{id:"_8-向前相容性-backwards-compatibility"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-向前相容性-backwards-compatibility"}},[t._v("#")]),t._v(" 8. 向前相容性（Backwards Compatibility）")]),t._v(" "),_("ul",[_("li",[t._v("這三個 opcode 在之前並未被使用，不會影響現有程式碼；只有在 EOFv1 格式中才會生效。")])])])}),[],!1,null,null,null);_.default=s.exports}}]);