(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{379:function(v,_,a){"use strict";a.r(_);var t=a(17),e=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"eip-7480-eof-資料區段存取指令"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#eip-7480-eof-資料區段存取指令"}},[v._v("#")]),v._v(" EIP-7480: EOF - 資料區段存取指令")]),v._v(" "),_("h2",{attrs:{id:"注意事項"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注意事項"}},[v._v("#")]),v._v(" 注意事項")]),v._v(" "),_("p",[v._v("本文並沒有經過作者外的其他審查者審核，因此若內容有誤，請到 issue 區提出問題，我會儘速修改，謝謝。")]),v._v(" "),_("h2",{attrs:{id:"摘要"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#摘要"}},[v._v("#")]),v._v(" 摘要")]),v._v(" "),_("p",[v._v("這個提案為 EOFv1 提供四個新指令，讓程式能夠讀取 EOF 容器中的資料區段：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("DATALOAD")]),v._v(" 將 32 位元組的資料載入堆疊")]),v._v(" "),_("li",[_("code",[v._v("DATALOADN")]),v._v(" 給定一個靜態立即參數，代表從指定位址載入 32 位元組資料到堆疊")]),v._v(" "),_("li",[_("code",[v._v("DATASIZE")]),v._v(" 將資料區段大小載入堆疊")]),v._v(" "),_("li",[_("code",[v._v("DATACOPY")]),v._v(" 將一部分的資料區段複製到記憶體")])]),v._v(" "),_("h2",{attrs:{id:"動機"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#動機"}},[v._v("#")]),v._v(" 動機")]),v._v(" "),_("p",[v._v("EOFv1 的重要特色之一是徹底分離程式碼區段與資料區段。這樣的設計使得資料區段可以包含任何內容，例如編譯器的詮釋資料，並且不需要在程式碼中進行任何額外的處理。\n然而因為分離，導致新的智慧合約無法使用原本的指令來存取這段資料，以太坊虛擬機（EVM）需要一套新的指令來讀取分離後的資料區段。\n因此為了避免混淆，在 EOFv1 中，原先使用於檢查位元組碼的相關指令（如 "),_("code",[v._v("CODECOPY")]),v._v("、"),_("code",[v._v("CODESIZE")]),v._v(" 等）已被棄用。\n並提供以下新指令來替換：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("DATALOAD")]),v._v("、"),_("code",[v._v("DATASIZE")]),v._v("、"),_("code",[v._v("DATACOPY")]),v._v(" 指令的設計模式如同現有的存取資料指令（比如對回傳資料 return data 與呼叫資料 call data）相似。")]),v._v(" "),_("li",[_("code",[v._v("DATALOADN")]),v._v(" 則是 "),_("code",[v._v("DATALOAD")]),v._v(" 的特化版本，能在編譯時期就設定好資料的讀取位置，因此不需要在執行時驗證，使得此指令更節省成本。")])]),v._v(" "),_("h2",{attrs:{id:"規格"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#規格"}},[v._v("#")]),v._v(" 規格")]),v._v(" "),_("p",[v._v("本 EIP 預計與 EIP-3540 一起生效，在相同的區塊高度上加入以下四個新指令：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("DATALOAD")]),v._v(" (0xd0)")]),v._v(" "),_("li",[_("code",[v._v("DATALOADN")]),v._v(" (0xd1)")]),v._v(" "),_("li",[_("code",[v._v("DATASIZE")]),v._v(" (0xd2)")]),v._v(" "),_("li",[_("code",[v._v("DATACOPY")]),v._v(" (0xd3)")])]),v._v(" "),_("p",[v._v("如果是傳統的 EVM 位元組碼，以上這些指令都會觸發「異常停止」。")]),v._v(" "),_("p",[v._v("如果是有效的 EOFv1 程式碼，則將以下述規則來執行：")]),v._v(" "),_("h3",{attrs:{id:"dataload"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dataload"}},[v._v("#")]),v._v(" "),_("code",[v._v("DATALOAD")])]),v._v(" "),_("ol",[_("li",[v._v("從堆疊彈出一個值 "),_("code",[v._v("offset")]),v._v("。")]),v._v(" "),_("li",[v._v("從資料區段讀取 "),_("code",[v._v("[offset:offset+32]")]),v._v(" 段落，並將其作為 32 位元組值推入堆疊。")]),v._v(" "),_("li",[v._v("如果 "),_("code",[v._v("offset + 32")]),v._v(" 大於資料區段大小，超出資料區段結尾的位元組會被設為 0。")]),v._v(" "),_("li",[v._v("消耗 4 單位 Gas。")])]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("堆疊變化示意圖：\n    \n    前                後\n+---------+     +-----------+\n| offset  |     | data[offs]|\n+---------+     +-----------+\n|   ...   |     |    ...    |\n+---------+     +-----------+\n")])])]),_("h3",{attrs:{id:"dataloadn"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dataloadn"}},[v._v("#")]),v._v(" "),_("code",[v._v("DATALOADN")])]),v._v(" "),_("ol",[_("li",[v._v("有一個立即參數 "),_("code",[v._v("offset")]),v._v("，以 16 位元無符號 bit-endian 方式來編碼。")]),v._v(" "),_("li",[v._v("不從堆疊彈出任何內容。")]),v._v(" "),_("li",[v._v("從資料區段讀取 "),_("code",[v._v("[offset:offset+32]")]),v._v(" 段落，並將其作為 32 位元組值推入堆疊。")]),v._v(" "),_("li",[v._v("消耗 3 單位 Gas。")])]),v._v(" "),_("p",[v._v("注意，因為此指令是在編譯時期就給定參數，因此在程式碼驗證的關卡會確保 "),_("code",[v._v("[offset:offset+32]")]),v._v(" 在資料區段範圍內。")]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("立即參數：offset (16位元)\n\n堆疊變化示意圖：\n    \n    前                後\n+---------+     +-----------+\n|   ...   |     | data[offs]|\n+---------+     +-----------+\n|   ...   |     |    ...    |\n+---------+     +-----------+\n")])])]),_("h3",{attrs:{id:"datasize"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#datasize"}},[v._v("#")]),v._v(" "),_("code",[v._v("DATASIZE")])]),v._v(" "),_("ol",[_("li",[v._v("不從堆疊彈出任何內容。")]),v._v(" "),_("li",[v._v("將當前容器的資料區段大小推入堆疊。")]),v._v(" "),_("li",[v._v("消耗 2 單位 Gas。")])]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("堆疊變化示意圖：\n    \n    前                後\n+---------+     +-----------+\n|   ...   |     | data_size |\n+---------+     +-----------+\n|   ...   |     |    ...    |\n+---------+     +-----------+\n")])])]),_("h3",{attrs:{id:"datacopy"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#datacopy"}},[v._v("#")]),v._v(" "),_("code",[v._v("DATACOPY")])]),v._v(" "),_("ol",[_("li",[v._v("從堆疊彈出三個值："),_("code",[v._v("mem_offset")]),v._v("、"),_("code",[v._v("offset")]),v._v("、"),_("code",[v._v("size")]),v._v("。")]),v._v(" "),_("li",[v._v("執行記憶體擴展到 "),_("code",[v._v("mem_offset + size")]),v._v(" 並扣除記憶體擴展成本。")]),v._v(" "),_("li",[v._v("消耗 "),_("code",[v._v("3 + 3 * ((size + 31) // 32)")]),v._v(" 單位 Gas 用於複製操作。")]),v._v(" "),_("li",[v._v("從資料區段讀取 "),_("code",[v._v("[offset:offset+size]")]),v._v(" 段落，並將其寫入從 "),_("code",[v._v("mem_offset")]),v._v(" 開始的記憶體位置。")]),v._v(" "),_("li",[v._v("如果 "),_("code",[v._v("offset + size")]),v._v(" 大於資料區段大小，則超出資料區段結尾的部分將以 0 填充。")])]),v._v(" "),_("div",{staticClass:"language-txt extra-class"},[_("pre",{pre:!0,attrs:{class:"language-txt"}},[_("code",[v._v("堆疊變化示意圖：\n    \n    前                後\n+---------+     \n|   size  |     \n+---------+     \n| offset  |     空堆疊\n+---------+     \n|mem_offset|    \n+---------+     +-----------+\n|   ...   |     |    ...    |\n+---------+     +-----------+\n\n記憶體變化：\n  mem_offset                 mem_offset+size\n      ↓                           ↓\n+-----+---------------------------+-----+\n|     |    從資料區段複製的資料     |     |\n+-----+---------------------------+-----+\n")])])]),_("h3",{attrs:{id:"程式碼驗證"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#程式碼驗證"}},[v._v("#")]),v._v(" 程式碼驗證")]),v._v(" "),_("p",[v._v("本 EIP 擴展了 EIP-3670 的程式碼區段驗證規則。")]),v._v(" "),_("ol",[_("li",[v._v("如果任何 "),_("code",[v._v("DATALOADN")]),v._v(" 的立即參數 "),_("code",[v._v("offset")]),v._v(" 使得 "),_("code",[v._v("offset + 32")]),v._v(" 大於"),_("em",[v._v("部署前")]),v._v("容器標頭檔中寫明的資料區段大小，則程式碼區段無效。")]),v._v(" "),_("li",[_("code",[v._v("RJUMP")]),v._v("、"),_("code",[v._v("RJUMPI")]),v._v(" 和 "),_("code",[v._v("RJUMPV")]),v._v(" 立即參數值（跳轉目標的相對偏移量）驗證：如果偏移量指向 "),_("code",[v._v("DATALOADN")]),v._v(" 指令後面的兩個位元組中的任一個，則程式碼區段無效。")])]),v._v(" "),_("h2",{attrs:{id:"目前設計上的選擇"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#目前設計上的選擇"}},[v._v("#")]),v._v(" 目前設計上的選擇")]),v._v(" "),_("h3",{attrs:{id:"缺少-extdatacopy"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缺少-extdatacopy"}},[v._v("#")]),v._v(" 缺少 "),_("code",[v._v("EXTDATACOPY")])]),v._v(" "),_("p",[_("code",[v._v("EXTCODECOPY")]),v._v(" 指令在 EOFv1 合約中被棄用並拒絕，當在傳統 EVM 程式碼呼叫 EOF 合約時，它將不會複製合約程式碼。主要只是想減少對於 EOF 合約的改動，雖然這個限制將導致依賴 "),_("code",[v._v("EXTCODECOPY")]),v._v(" 的純資料合約無法在 EOFv1 中使用，但如果確實有強烈需求（請廣大合約開發者擊鼓申冤，去提新的 EIP 來讓這件事發生的話），就可以在未來的升級中引入 "),_("code",[v._v("EXTDATACOPY")]),v._v(" 來恢復這些功能。")])])}),[],!1,null,null,null);_.default=e.exports}}]);