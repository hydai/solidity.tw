(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{362:function(e,n,r){"use strict";r.r(n);var a=r(17),t=Object(a.a)({},(function(){var e=this,n=e._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"erc1155-多元代幣標準-erc20-erc721-我全都要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#erc1155-多元代幣標準-erc20-erc721-我全都要"}},[e._v("#")]),e._v(" ERC1155 多元代幣標準 - ERC20 + ERC721 我全都要")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://eips.ethereum.org/EIPS/eip-1155",target:"_blank",rel:"noopener noreferrer"}},[e._v("ERC-1155 MULTI-TOKEN STANDARD"),n("OutboundLink")],1),e._v(" 定義了一個揉合 ERC20 與 ERC721 的新標準，他可以發行同值性代幣（如：ERC20）也能發行非同值性代幣（如：NFT ERC721）。")]),e._v(" "),n("h2",{attrs:{id:"介面"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介面"}},[e._v("#")]),e._v(" 介面")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('interface ERC1155 /* is ERC165 */ {\n    /// 當代幣被轉移時，`TransferSingle` 必須被觸發，即使是轉移 `0` 個代幣也是，轉移的行為包含「鑄造」與「銷毀」。\n    /// `_operator` 是發起交易的位址，即 `msg.sender`\n    /// `_from` 是持有者的位址；當「鑄造」新代幣時，此參數為位址 `0x0`\n    /// `_to` 是接收者的位址；當「銷毀」代幣時，此參數為位址 `0x0`\n    /// `_id` 為被轉移的 token ID\n    /// `_value` 為被轉移的 token 數量\n    event TransferSingle(address indexed _operator, address indexed _from, address indexed _to, uint256 _id, uint256 _value);\n\n    /// 當代幣被轉移時，`TransferBatch` 必須被觸發，即使是轉移 `0` 個代幣也是，轉移的行為包含「鑄造」與「銷毀」。\n    /// `_operator` 是發起交易的位址，即 `msg.sender`\n    /// `_from` 是持有者的位址；當「鑄造」新代幣時，此參數為位址 `0x0`\n    /// `_to` 是接收者的位址；當「銷毀」代幣時，此參數為位址 `0x0`\n    /// `_ids` 為被轉移的 token ID 列表\n    /// `_values` 為被轉移的 token 數量列表，其順序與長度需與 `_ids` 一致。\n    event TransferBatch(address indexed _operator, address indexed _from, address indexed _to, uint256[] _ids, uint256[] _values);\n\n    /// 授權事件，當持有者「授權」或「撤銷」第三方位址管理全部代幣的權力時被觸發。\n    /// `_owner` 為持有者位址\n    /// `_operator` 為被授權者位址\n    /// `_approved` 為授權(`true`)或撤銷(`false`)\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n    /// URI 更新事件\n    /// 當代幣的 URI 被更新時，必須觸發此事件\n    /// `_value` 代表更新後的 URI\n    /// `_id` 代表被更新的 token ID\n    event URI(string _value, uint256 indexed _id);\n\n    /// 呼叫者（`msg.sender`）從持有者（`_from`）轉移 `_value` 數量的特定代幣（`_id`）給接收者（`_to`）\n    /// 呼叫者應先獲得持有者的授權，或呼叫者就是持有者本人\n    /// 特殊情況：\n    ///    1. 當接收者（`_to`）為位址 `0x0` 時，回朔（revert）交易\n    ///    2. 當持有者（`_from`）所持有的代幣（`_id`）餘額低於要轉移的數量（`_value`）時，回朔交易\n    ///    3. 當發生任何錯誤時，回朔交易\n    /// 當此函式被呼叫時，必須觸發 `TransferSingle` 事件\n    function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external;\n\n        Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc).\n        After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see "Safe Transfer Rules" section of the standard).                      \n        @param _from    Source address\n        @param _to      Target address\n        @param _ids     IDs of each token type (order and length must match _values array)\n        @param _values  Transfer amounts per token type (order and length must match _ids array)\n        @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to`\n    */\n    /// 呼叫者（`msg.sender`）從持有者（`_from`）轉移 `_values` 數量的多種特定代幣（`_ids`）給接收者（`_to`）\n    /// 呼叫者應先獲得持有者的授權，或呼叫者就是持有者本人\n    /// 特殊情況：\n    ///    1. 當接收者（`_to`）為位址 `0x0` 時，回朔（revert）交易\n    ///    2. 當持有者（`_from`）所持有的任何一種代幣（`_ids`）餘額低於要轉移的對應數量（`_values`）時，回朔交易\n    ///.   3. 當轉移數量列表的長度與轉移代幣列表的長度不相符時，回朔交易\n    ///    3. 當發生任何錯誤時，回朔交易\n    /// 當此函式被呼叫時，必須觸發 `TransferBatch` 或 `TransferSingle` 事件，需特別注意，在事件中的轉移代幣與數量的順序應嚴格與呼叫此函式的代幣與數量順序一致。\n    function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external;\n\n    /// 查詢持有者帳戶中特定 token ID 的餘額\n    /// `_owner` 為持有者帳號\n    /// `_id` 為想查詢的 token id\n    /// 回傳該代幣的餘額\n    function balanceOf(address _owner, uint256 _id) external view returns (uint256);\n\n    /// 「帳戶」對「Token ID」的餘額列表\n    /// `_owners` 為持有者列表\n    /// `_ids` 為想查詢的 token id 列表\n    /// 回傳一個列表，每個餘額為對應順序的（持有者，Token ID）的餘額\n    function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory);\n\n    /// 呼叫者(`msg.sender`)授權給特定第三方位址管理所有代幣的權力\n    /// `_operator` 為第三方位址\n    /// `_approved` 為授權（`true`）或撤銷（`false`）\n    function setApprovalForAll(address _operator, bool _approved) external;\n\n    /// 查詢持有者是否授權給特定第三方位址\n    /// `_owner` 為持有者位址\n    /// `_operator` 為第三方位址\n    /// 回傳 true -> 有授權； false -> 沒有授權\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n')])])]),n("h2",{attrs:{id:"為什麼是我全都要"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#為什麼是我全都要"}},[e._v("#")]),e._v(" 為什麼是我全都要")]),e._v(" "),n("p",[e._v("實際上，ERC1155 算是對 ERC721 的改良。ERC721 只允許每個代幣只能有一個獨一無二的編號且數量為一。而 ERC1155 在建立代幣時，每個代幣可以指定發行的數量，因此就能做出擁有相同代幣編號，且數量超過一個情境。")]),e._v(" "),n("p",[e._v("如果想要發行同值性代幣（ERC20），則只需要在 ERC1155 中發行一種編號為 "),n("code",[e._v("0")]),e._v(" 的代幣，數量設定該代幣的總發行量即可。\n反之，若想發行非同值性代幣（ERC721），則在 ERC1155 中發行多種相異編號的代幣，每種類的數量都設定為 "),n("code",[e._v("1")]),e._v(" 即可。")])])}),[],!1,null,null,null);n.default=t.exports}}]);